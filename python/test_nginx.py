
#
# Copyright (C) 2022 Fortanix, Inc. All Rights Reserved.
#

import filecmp
import json
import os
import sys
import time
from OpenSSL import crypto
from test_app import MalborkContainer, TestApp, main
from test_utils import TestException, remove_ignore_nonexistent


class NginxEnum :
  Appcert = "appcert"
  EFS = "efs"


class TestNginx(TestApp):

    TestVersion = NginxEnum.Appcert  # Class variable

    def verifyIssuer(self, cert_filename, cacert_filename):
        with open(cert_filename, 'r', encoding="ascii") as f:
            cert_str = f.read()
        certificate = crypto.load_certificate(crypto.FILETYPE_PEM, cert_str)

        try:
            store = crypto.X509Store()

            with open(cacert_filename, 'r', encoding="ascii") as f1:
                ca_cert_str = f1.read()

            ca_certificate = crypto.load_certificate(crypto.FILETYPE_PEM, ca_cert_str)
            store.add_cert(ca_certificate)
            store_ctx = crypto.X509StoreContext(store, certificate)
            store_ctx.verify_certificate()
            return True

        except Exception as e:
            print(e)
            return False

    def __init__(self, run_args, *_) :
        super().__init__(run_args, [])
        print(f'Info: Testing {TestNginx.TestVersion}')
        self.saved_file = 'index.html'
        self.saved_ssl_file = 'ssl.html'
        self.retries = 60

    def run(self):
        remove_ignore_nonexistent(self.saved_file)
        remove_ignore_nonexistent(self.saved_ssl_file)

        # Our nginx container serves HTTP on port 80 and HTTPS on port 443. In order for our client program to
        # interact with the nginx process without itself running in the same network namespace as nginx, we ask
        # Docker to pass these ports through to the host. By requesting port 'None', we ask for a random host port
        # so we don't have to worry about port conflicts with other software running on the test host.
        malbork_container = MalborkContainer()
        malbork_container.start()
        env_malbork=malbork_container.get_env_var()
        os.environ.update(env_malbork)
        node_url = malbork_container.get_node_base_url()

        ports = {
            80: None,
            443: None,
        }

        # Obtain the CA certificate from malbork backend
        ca_cert = malbork_container.get_zone_cert()
        if not ca_cert:
            raise TestException('Unable to get CA cert')

        ca_path = "/etc/nginx/nginx_ca.crt"
        ca_cert_info = json.dumps({"ca_certificates" : [
            {
                "caPath" : ca_path,
                "caCert" : ca_cert,
                "system" : 'undefined'
            }
        ]})

        if TestNginx.TestVersion == NginxEnum.Appcert :
            keyfile = '/etc/nginx/nginx-key.pem'
            certfile = '/etc/nginx/nginx-cert.pem'
            read_write_dirs = [ '/var/cache/nginx', '/var/run', '/run', '/etc/nginx' ]
        elif TestNginx.TestVersion == NginxEnum.EFS :
            keyfile = '/run/nginx-key.pem'
            certfile = '/run/nginx-cert.pem'
            read_write_dirs = [ '/var/cache/nginx', '/etc/nginx' ]
        else :
            raise TestException("TestVersion is not 'appcert' or 'efs'")

        cert_info = json.dumps({"certificates": [
            {
                "issuer": "MANAGER_CA",
                "subject": "Fortanix-nginx-curated-app",
                "keyType": "rsa",
                "keyParam": { "size": 2048 },
                "keyPath": keyfile,
                "chainPath": certfile,
            }
        ]})

        container = self.container('nginx', image_version='1.15.2',
                memsize='2G',
                registry='library',  network_mode='bridge',
                certificates=cert_info,
                container_env={'NODE_AGENT_BASE_URL':node_url},
                ports=ports, ca_certificates=ca_cert_info,
                rw_dirs=read_write_dirs,
                hostname='Fortanix-nginx-curated-app')

        scriptDirectory = os.path.dirname(os.path.realpath(sys.argv[ 0 ]))
        ref_file = os.path.join(scriptDirectory, 'reference-output.html')
        ssl_conf = os.path.join(scriptDirectory, 'ssl.conf')

        container.prepare()
        # Following key and cert at path below will be generated by manager
        #'nginx-cert.pem' --> '/etc/nginx'
        #'nginx-key.pem' -->  '/etc/nginx'
        container.copy_file(ssl_conf, '/etc/nginx/conf.d')
        container.run()

        ### NOT EFS
        if TestNginx.TestVersion == NginxEnum.Appcert :
          self.check_CA_trust_store( container, ca_cert )

        # We are using global bridge network from test_app
        # So don't need to port map but use IP.
        http_port = 80
        https_port = 443
        nginx_ip = container.get_my_ip()

        print(f'Nginx running with http on ip {nginx_ip} port {http_port} and https on port {https_port}')
        # nginx can take a while before it's serving requests, especially
        # on SGX. Try hitting it with wget a few times until it's serving
        # requests.
        for _ in range(self.retries):
            if os.system(f'wget -nv -O {self.saved_file} http://{nginx_ip}:{http_port}') == 0 :
                break
            time.sleep(2)

        if not os.path.isfile(self.saved_file):
            raise TestException('Unable to connect with HTTP')

        if not filecmp.cmp(self.saved_file, ref_file):
            raise TestException('nginx returned incorrect data')

        #### NOT EFS
        if TestNginx.TestVersion == NginxEnum.Appcert :
          self.verify_certificate(container, ca_path)

        if os.system(f'wget --no-check-certificate -nv -O {self.saved_ssl_file} https://{nginx_ip}:{https_port}') != 0 :
            raise TestException('nginx wget fail over HTTPS')

        if not os.path.isfile(self.saved_ssl_file):
            raise TestException('Unable to connect with HTTPS')

        if not filecmp.cmp(self.saved_ssl_file, ref_file):
            raise TestException('nginx returned incorrect data over HTTPS')

        return True


    def check_CA_trust_store( self, container, ca_cert ) :

        # Check if the CA certificate was installed in the trust store
        status = container.check_CA_trust_store('/etc/ssl/certs/ca-certificates.crt', ca_cert)
        if status is not True:
            print("CA cert was not installed in the trust store.")



    def verify_certificate( self, container, ca_path ) :

        # Copy the server cert file from the container. The server cert's issuer
        # is manually verified here. We can't pass the CA cert file to wget as it also
        # checks for hostname-CN match which will fail in this test. We have not yet
        # set the hostname for the container and supported DNS resolution.
        copied_cert_file = './nginx-cert.pem'
        copied_ca_file = './ca_path'
        container.copy_file_from_container('/etc/nginx/nginx-cert.pem',copied_cert_file)
        container.copy_file_from_container(ca_path, copied_ca_file)

        if self.verifyIssuer(copied_cert_file, copied_ca_file) is not True :
            raise TestException('Unable to verify certificate.')

        self.info('Certificate issuer has been verified manually. ')
        remove_ignore_nonexistent(copied_ca_file)
        remove_ignore_nonexistent(copied_cert_file)


def test_nginx_efs( ) :
    TestNginx.TestVersion = NginxEnum.EFS
    main(TestNginx)

def test_nginx_appcert( ) :
    TestNginx.TestVersion = NginxEnum.Appcert
    main(TestNginx)
