#!/usr/bin/python3
#
# Copyright (c) Fortanix, Inc.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
###############################################################
## Usage:
## For custom setting of Number of Rows in sysbench, set
## export SYSBENCH_ROWS=1000,10000,500000
##
## For custom setting of Number of Threads in sysbench, set
## export SYSBENCH_THREADS=2,4,8
##
###############################################################

import argparse
import MySQLdb
import os
import pandas
import pexpect
import test_app
from test_utils import random_string

MYSQL_PORT = 3306

class ColumnNames:
    '''
    String names for the columns to be printed in the .csv data file that
    is generated by the script with the benchmark results.

    The COLUMN_ORDER list controls the order in which the columns are
    sorted in the output .csv file. Changing the order of this list will
    change the order in the .csv file.
    '''
    ROWS = "Rows"
    THREADS = "Threads"
    OPS = "Total Operations"
    TRANSACTIONS = "Total Transactions"
    MIN_LATENCY = "Min Latency"
    MAX_LATENCY = "Max Latency"
    PCT_95 = "95th Percentile"

    COLUMN_ORDER = [ ROWS, THREADS, OPS, TRANSACTIONS, MIN_LATENCY, MAX_LATENCY, PCT_95 ]

class TestMysql(test_app.TestApp):
    def __init__(self, run_args, test_arg_list):
        super(TestMysql, self).__init__(run_args, [])
        parser = argparse.ArgumentParser(description='Mysql test')
        self.args = parser.parse_args(test_arg_list)
        self.benchmark = pandas.DataFrame()
        self.duration = str(run_args.benchmark_duration)
        print ("== Duration for each benchmark param run is: {} seconds==".format(self.duration))
        if 'SYSBENCH_ROWS' in os.environ:
            self.NUM_ROWS = os.environ.get('SYSBENCH_ROWS').split(',')
        else:
            self.NUM_ROWS = [1000,10000,50000,100000]
        if 'SYSBENCH_THREADS' in os.environ:
            self.setup_num_threads()


    def get_timeout(self):
        return 7200

    def setup_num_threads(self):
        thread = os.environ.get('SYSBENCH_THREADS').split(',')
        with open("run.sh", "r+") as f:
            lines = f.readlines()
            f.seek(0)
            for line in lines:
                if "for threads in " in line:
                    s = 'for threads in '
                    for t in thread:
                        s = s + t + ' '
                    s = s + '; do '
                    f.write(s + '\n')
                    continue
                f.write(line)
            f.truncate()

    def create_db_sysbench(self, db_name, ip, port, passwd):
        db = MySQLdb.connect(host=ip, user='root', passwd=passwd, port=port)
        cur = db.cursor()
        cmd = "create database {};".format(db_name)
        cur.execute(cmd)
        cur.execute('GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'localhost\';')
        cur.execute('FLUSH PRIVILEGES;')
        print ('Database {} created successfully'.format(db_name))


    def parse_output_result(self, rows, container_type):
        f = open('output.txt', 'r')
        lines = f.readlines()
        f.close()
        benchmark = {}
        benchmark[container_type] = {}
        benchmark[container_type][ColumnNames.ROWS] = rows
        for line in lines:
            if "Number of threads" in line:
                benchmark[container_type][ColumnNames.THREADS] = int(line.split()[-1])
            if "total:" in line:
                benchmark[container_type][ColumnNames.OPS] = line.split()[-1]
            if "transactions:" in line:
                benchmark[container_type][ColumnNames.TRANSACTIONS] = line.split()[1]
            if "min:" in line:
                benchmark[container_type][ColumnNames.MIN_LATENCY] = line.split()[-1]
            if "max:" in line:
                benchmark[container_type][ColumnNames.MAX_LATENCY] = line.split()[-1]
            if "approx.  95 percentile:" in line:
                benchmark[container_type][ColumnNames.PCT_95] = line.split()[-1]
                out = pandas.DataFrame(benchmark).T
                self.benchmark = pandas.concat([self.benchmark,out])



    def prepare_and_run_sysbench_workload(self, mysql_port, mysql_ip, passwd, output_of = None):
        manifest_env = ['MYSQL_ROOT_PASSWORD={}'.format(passwd)]
        ports = {
            MYSQL_PORT: None
        }
        params = {}
        params['rw_dirs'] = ['/var/lib/mysql','/etc/mysql','/tmp','/run/mysqld']
        params['image_name'] = 'zapps/mariadb-client'
        params['image_version'] = '20190625-1560d46'
        params['run_args'] = self.run_args
        params['manifest_env'] = manifest_env
        params['ports'] = ports
        for num_rows in self.NUM_ROWS:
            db_name = 'sbtest_' + self.run_args.mariadb_workload + '_' + str(num_rows)
            self.create_db_sysbench(db_name, mysql_ip, mysql_port, passwd)
            if 'complex' in self.run_args.mariadb_workload:
                params['entrypoint'] = ['/root/run.sh', passwd, str(mysql_port), mysql_ip, str(self.duration), db_name, str(num_rows), 'oltp-test-mode=complex']
            else:
                params['entrypoint'] = ['/root/run.sh', passwd, str(mysql_port), mysql_ip, str(self.duration), db_name, str(num_rows), 'oltp-read-only=on']

            client = test_app.NativeContainer(
                params['image_name'],
                image_version = params['image_version'],
                rw_dirs=params['rw_dirs'],
                manifest_env=params['manifest_env'],
                ports=params['ports'],
                run_args=params['run_args'],
                entrypoint=params['entrypoint'])


            print ('Moving ahead to start MariaDB Client Container')
            client.prepare()
            client.copy_file('run.sh', '/root')
            client.run()

            client.container.wait()
            client.copy_file_from_container('output.txt', 'output.txt')
            self.parse_output_result(num_rows, self.run_args.container_env)

    def create_and_run_mariadb_container(self):
        ports = {
            MYSQL_PORT: None
        }
        passwd = random_string(8)
        print ("Password is :" + passwd)
        manifest_env = ['MYSQL_ROOT_PASSWORD={}'.format(passwd)]
        params = {}
        params['memsize'] = '2048M'
        params['thread_num'] = 130
        params['auto_remove'] = False
        params['ports'] = ports
        params['pexpect'] = True
        params['pexpect_tmo'] = 1200
        params['manifest_env'] = manifest_env
        params['rw_dirs'] = ['/var/lib/_mysql', '/etc/mysql']
        params['encrypted_dirs'] = ['/var/lib/mysql', '/tmp','/run/mysqld']
        persist_vol_name = test_app.gen_volume_name('test-mariadb-sysbench')
        container = None
        if 'zircon' in self.run_args.container_env:
            params['image_name'] = 'zapps/mariadb'
            params['persistent_volume'] = {persist_vol_name: '/var/lib/mysql'}
            container = self.container(
                params['image_name'],
                memsize=params['memsize'],
                thread_num=params['thread_num'],
                auto_remove=params['auto_remove'],
                encrypted_dirs=params['encrypted_dirs'],
                rw_dirs=params['rw_dirs'],
                persistent_volume=params['persistent_volume'],
                manifest_env=params['manifest_env'],
                ports=params['ports'],
                pexpect=params['pexpect'],
                pexpect_tmo=params['pexpect_tmo'])

        if 'native' in self.run_args.container_env:
            params['image_name'] = 'mariadb'
            params['image_version'] = '10.3.11'
            params['registry'] = 'library'
            params['run_args'] = self.run_args
            container = test_app.NativeContainer(
                params['image_name'],
                image_version=params['image_version'],
                registry=params['registry'],
                rw_dirs=params['rw_dirs'],
                manifest_env=params['manifest_env'],
                ports=params['ports'],
                pexpect=params['pexpect'],
                pexpect_tmo=params['pexpect_tmo'],
                run_args=params['run_args'])

        if not container:
            raise ValueError('run_args.container_env is not set.')

        container.prepare()
        container.run()
        mysql_port = MYSQL_PORT
        mysql_ip = container.get_my_ip()
        try:
            if 'zircon' in self.run_args.container_env:
                container.expect(r'mysqld: Shutdown complete')
            container.expect(r'ready for connections')
        except pexpect.ExceptionPexpect:
                container.dump_output()
                self.info('')
                self.error('Failed to start mysql.')
                return
        import time
        time.sleep(30)
        self.prepare_and_run_sysbench_workload(mysql_port, mysql_ip, passwd, output_of=self.run_args.container_env)

    def run(self):
        os.chdir(os.path.dirname(__file__))
        self.create_and_run_mariadb_container()
        sorted_benchmark = self.benchmark.sort_values([ColumnNames.ROWS, ColumnNames.THREADS],ascending=[True, True])
        sorted_benchmark.to_csv('mariadb-benchmarks-results.csv', mode='a', header=True, columns=ColumnNames.COLUMN_ORDER)
        print ('Benchmark results stored in file mariadb-benchmarks-results.csv')
        return True

if __name__ == '__main__':
    test_app.main(TestMysql)
